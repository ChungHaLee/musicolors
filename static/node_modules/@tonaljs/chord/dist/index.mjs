// index.ts
import { detect } from "@tonaljs/chord-detect";
import {
  all as chordTypes,
  get as getChordType
} from "@tonaljs/chord-type";
import {
  deprecate,
  distance,
  note,
  tokenizeNote,
  transpose as transposeNote
} from "@tonaljs/core";
import { isSubsetOf, isSupersetOf } from "@tonaljs/pcset";
import { all as scaleTypes } from "@tonaljs/scale-type";
import { detect as detect2 } from "@tonaljs/chord-detect";
var NoChord = {
  empty: true,
  name: "",
  symbol: "",
  root: "",
  rootDegree: 0,
  type: "",
  tonic: null,
  setNum: NaN,
  quality: "Unknown",
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
var NUM_TYPES = /^(6|64|7|9|11|13)$/;
function tokenize(name) {
  const [letter, acc, oct, type] = tokenizeNote(name);
  if (letter === "") {
    return ["", name];
  }
  if (letter === "A" && type === "ug") {
    return ["", "aug"];
  }
  if (!type && (oct === "4" || oct === "5")) {
    return [letter + acc, oct];
  }
  if (NUM_TYPES.test(oct)) {
    return [letter + acc, oct + type];
  } else {
    return [letter + acc + oct, type];
  }
}
function get(src) {
  if (src === "") {
    return NoChord;
  }
  if (Array.isArray(src) && src.length === 2) {
    return getChord(src[1], src[0]);
  } else {
    const [tonic, type] = tokenize(src);
    const chord2 = getChord(type, tonic);
    return chord2.empty ? getChord(src) : chord2;
  }
}
function getChord(typeName, optionalTonic, optionalRoot) {
  const type = getChordType(typeName);
  const tonic = note(optionalTonic || "");
  const root = note(optionalRoot || "");
  if (type.empty || optionalTonic && tonic.empty || optionalRoot && root.empty) {
    return NoChord;
  }
  const rootInterval = distance(tonic.pc, root.pc);
  const rootDegree = type.intervals.indexOf(rootInterval) + 1;
  if (!root.empty && !rootDegree) {
    return NoChord;
  }
  const intervals = Array.from(type.intervals);
  for (let i = 1; i < rootDegree; i++) {
    const num = intervals[0][0];
    const quality = intervals[0][1];
    const newNum = parseInt(num, 10) + 7;
    intervals.push(`${newNum}${quality}`);
    intervals.shift();
  }
  const notes = tonic.empty ? [] : intervals.map((i) => transposeNote(tonic, i));
  typeName = type.aliases.indexOf(typeName) !== -1 ? typeName : type.aliases[0];
  const symbol = `${tonic.empty ? "" : tonic.pc}${typeName}${root.empty || rootDegree <= 1 ? "" : "/" + root.pc}`;
  const name = `${optionalTonic ? tonic.pc + " " : ""}${type.name}${rootDegree > 1 && optionalRoot ? " over " + root.pc : ""}`;
  return {
    ...type,
    name,
    symbol,
    type: type.name,
    root: root.name,
    intervals,
    rootDegree,
    tonic: tonic.name,
    notes
  };
}
var chord = deprecate("Chord.chord", "Chord.get", get);
function transpose(chordName, interval) {
  const [tonic, type] = tokenize(chordName);
  if (!tonic) {
    return chordName;
  }
  return transposeNote(tonic, interval) + type;
}
function chordScales(name) {
  const s = get(name);
  const isChordIncluded = isSupersetOf(s.chroma);
  return scaleTypes().filter((scale) => isChordIncluded(scale.chroma)).map((scale) => scale.name);
}
function extended(chordName) {
  const s = get(chordName);
  const isSuperset = isSupersetOf(s.chroma);
  return chordTypes().filter((chord2) => isSuperset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
function reduced(chordName) {
  const s = get(chordName);
  const isSubset = isSubsetOf(s.chroma);
  return chordTypes().filter((chord2) => isSubset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
var chord_default = {
  getChord,
  get,
  detect,
  chordScales,
  extended,
  reduced,
  tokenize,
  transpose,
  chord
};
export {
  chord,
  chordScales,
  chord_default as default,
  detect2 as detect,
  extended,
  get,
  getChord,
  reduced,
  tokenize,
  transpose
};
//# sourceMappingURL=index.mjs.map